import {
  QueryConstraint,
  addDoc,
  arrayRemove,
  arrayUnion,
  collection,
  doc,
  getDoc,
  getDocs,
  limit,
  orderBy,
  query,
  setDoc,
  startAfter,
  updateDoc,
  where,
} from 'firebase/firestore';
import { getDownloadURL, ref, uploadBytes } from 'firebase/storage';
import { FIREBASE_DB, FIREBASE_STORAGE } from '../../FirebaseConfig';
import { UserBookmarks } from '../../types/UserBookmarks';
import convertFirestoreRecipeToAppRecipe from '../../utils/convertFirestoreRecipeToAppRecipe';
import { Recipe } from '../model/recipeModel';

export async function addRecipeToFirestore(
  recipeData: Recipe,
  userId: string
): Promise<string> {
  try {
    const docRef = await addDoc(collection(FIREBASE_DB, 'recipes'), {
      ...recipeData,
      userId, // Store the user ID with the recipe
      createdAt: new Date(), // Set the current date as the creation date
      updatedAt: new Date(), // Set the current date as the updated date
    });
    console.log('Recipe added to Firestore');
    return docRef.id; // Return the generated recipe ID
  } catch (error) {
    console.error('Error adding recipe to Firestore:', error);
    throw error;
  }
}

export async function getAllRecipes(
  lastFetchedRecipeId: string | null,
  limitNumber: number,
  userId?: string
) {
  // Create an array for query constraints
  let queryConstraints: Array<QueryConstraint> = [
    orderBy('updatedAt', 'desc'),
    limit(limitNumber),
  ];

  // Filter by userId if provided
  if (userId) {
    queryConstraints.push(where('userId', '==', userId));
  }

  // Modify the query if lastFetchedRecipeId exists
  if (lastFetchedRecipeId) {
    const lastSnapshot = await getDoc(
      doc(FIREBASE_DB, 'recipes', lastFetchedRecipeId)
    );
    queryConstraints.push(startAfter(lastSnapshot));
  }

  // Construct the final query using the query constraints
  const finalQuery = query(
    collection(FIREBASE_DB, 'recipes'),
    ...queryConstraints
  );

  // Execute the query and process the results

  const querySnapshot = await getDocs(finalQuery);
  const fetchedRecipes = querySnapshot.docs.map(
    convertFirestoreRecipeToAppRecipe
  );

  // Determine the new 'lastFetchedRecipeId' for pagination
  const newLastFetchedRecipeId =
    querySnapshot.docs.length === limitNumber
      ? querySnapshot.docs[querySnapshot.docs.length - 1].id
      : null;
  console.log('Recipes fetched:', fetchedRecipes);
  return {
    recipes: fetchedRecipes,
    lastFetchedRecipeId: newLastFetchedRecipeId,
  };
}

export async function getAllSearchedRecipes(
  lastFetchedRecipeId: string | null,
  userId?: string
) {
  // Create an array for query constraints
  let queryConstraints: Array<QueryConstraint> = [orderBy('updatedAt', 'desc')];

  // Filter by userId if provided
  if (userId) {
    queryConstraints.push(where('userId', '==', userId));
  }

  // Modify the query if lastFetchedRecipeId exists
  if (lastFetchedRecipeId) {
    const lastSnapshot = await getDoc(
      doc(FIREBASE_DB, 'recipes', lastFetchedRecipeId)
    );
    queryConstraints.push(startAfter(lastSnapshot));
  }

  // Construct the final query using the query constraints
  const finalQuery = query(
    collection(FIREBASE_DB, 'recipes'),
    ...queryConstraints
  );

  // Execute the query and process the results
  const querySnapshot = await getDocs(finalQuery);
  const fetchedRecipes = querySnapshot.docs.map(
    convertFirestoreRecipeToAppRecipe
  );

  // Determine the new 'lastFetchedRecipeId' for pagination
  const newLastFetchedRecipeId =
    querySnapshot.docs.length > 0
      ? querySnapshot.docs[querySnapshot.docs.length - 1].id
      : null;

  console.log('Searched recipes fetched:', fetchedRecipes);

  return {
    recipes: fetchedRecipes,
    lastFetchedRecipeId: newLastFetchedRecipeId,
  };
}

// Get recipe by id from Firestore database
export async function getRecipeById(recipeId: string) {
  try {
    const docRef = doc(FIREBASE_DB, 'recipes', recipeId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      // Convert Firestore document to RecipeWithId type
      return convertFirestoreRecipeToAppRecipe(docSnap);
    } else {
      console.log('No such document!');
      return null;
    }
  } catch (error) {
    console.error('Error fetching document:', error);
    throw error;
  }
}

export async function getRecipesByIdsFromFirestore(recipeIds: string[]) {
  try {
    const recipePromises = recipeIds.map((id) => getRecipeById(id));
    const recipes = await Promise.all(recipePromises);
    return recipes.filter((recipe) => recipe !== null);
  } catch (error) {
    console.error('Error fetching recipes:', error);
    throw error;
  }
}

// Add image with an autogenerated id to Firestore database
export const addImage = async (imageData: { imageUrl: string }) => {
  try {
    await addDoc(collection(FIREBASE_DB, 'images'), imageData);
    console.log('Image added to Firestore');
  } catch (error) {
    console.error('Error adding image to Firestore:', error);
    throw error;
  }
};

// Get image by id from Firestore database
export async function getImageById(imageId: string) {
  try {
    const docRef = doc(FIREBASE_DB, 'images', imageId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return docSnap.data(); // Returns the document data
    } else {
      console.log('No such document!');
      return null;
    }
  } catch (error) {
    console.error('Error fetching document:', error);
    throw error;
  }
}

export async function uploadImageToFirestore(
  localFilePath: string,
  recipeId: string
): Promise<string | null> {
  try {
    const storageRef = ref(FIREBASE_STORAGE, `recipes/${recipeId}.jpg`);
    const response = await fetch(localFilePath);
    const blob = await response.blob();
    await uploadBytes(storageRef, blob);
    const downloadURL = await getDownloadURL(storageRef);
    await updateDoc(doc(FIREBASE_DB, 'recipes', recipeId), {
      imageUrl: downloadURL,
    });
    return downloadURL;
  } catch (error) {
    console.error('Error uploading image:', error);
    return null; // Return null in case of error
  }
}

// Firestore service functions for bookmarks
const bookmarksRef = collection(FIREBASE_DB, 'bookmarks');

export async function addBookmarkToFirestore(
  userId: string,
  recipeId: string
): Promise<void> {
  try {
    const userBookmarkDocRef = doc(bookmarksRef, userId);
    await setDoc(
      userBookmarkDocRef,
      {
        recipeIds: arrayUnion(recipeId),
      },
      { merge: true }
    );
  } catch (error) {
    console.error('Error adding bookmark:', error);
    throw error; // Re-throw the error if you want to handle it in the caller
  }
}

export async function removeBookmarkFromFirestore(
  userId: string,
  recipeId: string
): Promise<void> {
  try {
    const userBookmarkDocRef = doc(bookmarksRef, userId);
    await updateDoc(userBookmarkDocRef, {
      recipeIds: arrayRemove(recipeId),
    });
  } catch (error) {
    console.error('Error removing bookmark:', error);
    throw error;
  }
}

export async function getBookmarksFromFirestore(
  userId: string
): Promise<string[]> {
  try {
    const userBookmarkDocRef = doc(bookmarksRef, userId);
    const docSnap = await getDoc(userBookmarkDocRef);

    if (docSnap.exists()) {
      const data = docSnap.data() as UserBookmarks;
      return data.recipeIds;
    } else {
      // Initialize the bookmarks document for new users
      await setDoc(userBookmarkDocRef, { recipeIds: [] });
      return [];
    }
  } catch (error) {
    console.error('Error fetching bookmarks:', error);
    throw error;
  }
}
