import { getAuth } from 'firebase/auth';
import {
  addDoc,
  collection,
  doc,
  getDoc,
  getDocs,
  limit,
  orderBy,
  query,
  setDoc,
  startAfter,
} from 'firebase/firestore';
import { getDownloadURL, ref, uploadBytes } from 'firebase/storage';
import { FIREBASE_DB, FIREBASE_STORAGE } from '../../FirebaseConfig';
import { Recipe } from '../model/recipeModel';

// Add recipe with an autogenerated id to Firestore database
export async function addRecipe(recipeData: Recipe): Promise<string> {
  const auth = getAuth();
  const user = auth.currentUser;

  if (!user) {
    console.error('No authenticated user found');
    throw new Error('Unauthorized access'); // Prevent further execution
  }

  try {
    // Include the additional fields in the recipe data
    const docRef = await addDoc(collection(FIREBASE_DB, 'recipes'), {
      ...recipeData,
      userId: user.uid, // Store the user ID with the recipe
      createdAt: new Date(), // Set the current date as the creation date
      updatedAt: new Date(), // Set the current date as the updated date
    });
    console.log('Recipe added to Firestore');
    return docRef.id; // Return the generated recipe ID
  } catch (error) {
    console.error('Error adding recipe to Firestore:', error);
    throw error;
  }
}

// Fetch all recipes from Firestore
// export async function getAllRecipes() {
//   const recipes: Array<Recipe & { id: string }> = []; // Define the type of array with an additional 'id' property
//   const querySnapshot = await getDocs(collection(FIREBASE_DB, 'recipes'));
//   querySnapshot.forEach((doc) => {
//     // Combine the document data with the document ID
//     const recipeData = doc.data() as Recipe; // Cast the document data to the Recipe type
//     recipes.push({ ...recipeData, id: doc.id }); // Add the id property
//   });
//   return recipes;
// }

export async function getAllRecipes(
  lastFetchedRecipeId: string | null = null,
  limitNumber: number = 2
) {
  // Base query with ordering and limiting
  let baseQuery = query(
    collection(FIREBASE_DB, 'recipes'),
    orderBy('updatedAt', 'desc'),
    limit(limitNumber)
  );

  // Modify the query if lastFetchedRecipeId exists
  let finalQuery;
  if (lastFetchedRecipeId) {
    const lastSnapshot = await getDoc(
      doc(FIREBASE_DB, 'recipes', lastFetchedRecipeId)
    );
    finalQuery = query(baseQuery, startAfter(lastSnapshot));
  } else {
    finalQuery = baseQuery;
  }

  const querySnapshot = await getDocs(finalQuery);

  const fetchedRecipes = querySnapshot.docs.map((doc) => ({
    ...(doc.data() as Recipe),
    id: doc.id,
  }));

  // Determine the new 'lastFetchedRecipeId' for pagination
  const newLastFetchedRecipeId =
    querySnapshot.docs.length === limitNumber
      ? querySnapshot.docs[querySnapshot.docs.length - 1].id
      : null;

  return {
    recipes: fetchedRecipes,
    lastFetchedRecipeId: newLastFetchedRecipeId,
  };
}

// Get recipe by id from Firestore database
export async function getRecipeById(recipeId: string) {
  try {
    const docRef = doc(FIREBASE_DB, 'recipes', recipeId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return docSnap.data(); // Returns the document data
    } else {
      console.log('No such document!');
      return null;
    }
  } catch (error) {
    console.error('Error fetching document:', error);
    throw error;
  }
}

// Add image with an autogenerated id to Firestore database
export const addImage = async (imageData: { imageUrl: string }) => {
  try {
    await addDoc(collection(FIREBASE_DB, 'images'), imageData);
    console.log('Image added to Firestore');
  } catch (error) {
    console.error('Error adding image to Firestore:', error);
    throw error;
  }
};

// Get image by id from Firestore database
export async function getImageById(imageId: string) {
  try {
    const docRef = doc(FIREBASE_DB, 'images', imageId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return docSnap.data(); // Returns the document data
    } else {
      console.log('No such document!');
      return null;
    }
  } catch (error) {
    console.error('Error fetching document:', error);
    throw error;
  }
}

// Upload recipe image to Firestore
export default function uploadImageToFirestore(
  localFilePath: string,
  recipeId: string
) {
  return new Promise(async (resolve, reject) => {
    try {
      // Create a storage reference with the recipe ID
      const storageRef = ref(FIREBASE_STORAGE, `recipes/${recipeId}.jpg`);

      // Convert the local file path to a Blob or File object
      const response = await fetch(localFilePath);
      const blob = await response.blob();

      // Upload the file to Firebase Storage
      await uploadBytes(storageRef, blob);

      // Get the download URL
      const downloadURL = await getDownloadURL(storageRef);

      // Save the download URL to Firestore
      const recipeRef = doc(FIREBASE_DB, 'recipes', recipeId);
      await setDoc(recipeRef, { imageUrl: downloadURL }, { merge: true });

      resolve(downloadURL);
    } catch (error) {
      console.error('Error uploading image:', error);
      reject(error);
    }
  });
}
